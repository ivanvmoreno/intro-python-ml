---
title: "Introducci√≥n a ML con Python üêç"
subtitle: "00_01 - Python 101"
author: "Iv√°n Moreno"
lang: "es"
format: 
  revealjs:
    embed-resources: true
    theme: [dark]
    output-location: fragment
execute:
    echo: true
engine: jupyter
editor_options: 
  markdown: 
    wrap: 99
---

# Python 101

## ¬øQu√© es Python?

::: {.incremental}

* Lenguaje de programaci√≥n interpretado (no compilado)
* Multiplataforma
* Multiparadigma (imperativo, orientado a objetos, funcional)
* Tipado din√°mico (no es necesario declarar el tipo de las variables)
* Orientado a objetos
* Extensible (m√≥dulos y paquetes) y portable (e.g., Jython, una implementaci√≥n de Python que corre sobre la JVM)

:::

## ¬øPor qu√© Python?

::: {.incremental}

* Sintaxis sencilla y legible (indentaci√≥n)
* Gran cantidad de librer√≠as (compatible con C y C++)
* Comunidad activa
* Multiplataforma

:::


# Instalaci√≥n

## Anaconda

* Distribuci√≥n de Python (y R) para computaci√≥n cient√≠fica
* Gestor de paquetes (conda)
* Gestor de entornos (conda)
* Dos versiones: Anaconda (GUI, ~3GB) y Miniconda (CLI, ~400MB)

. . .

![](img/anaconda.png)

## Jupyter

* Cuaderno de notas interactivo para la computaci√≥n cient√≠fica
* Celdas de c√≥digo, texto (Markdown) e im√°genes / gr√°ficos
* Kernels (procesos encargados de ejecutar el c√≥digo en un lenguaje determinado)
* Interfaz web (Jupyter Notebook)

. . .

![](img/jupyter_notebook.webp)

## Descarga Anaconda

[https://www.anaconda.com/products/distribution#Downloads](https://www.anaconda.com/products/distribution#Downloads)

![](img/anaconda_down.png)

## Inicializaci√≥n del entorno

* Windows: Anaconda Prompt
* Linux & Mac: Terminal

. . .

```bash
conda create -n intro python=3.11
conda activate intro
python --version
python -i -c "print('sss üêç')" # Ctrl + D o exit() para salir
```

## Gesti√≥n de entornos con `conda`

::: {.incremental}

* Crear un entorno: `conda create -n <nombre> python=<versi√≥n>`
* Activar un entorno: `conda activate <nombre>`
* Desactivar un entorno: `conda deactivate`
* Eliminar un entorno: `conda env remove -n <nombre> --all`
* Listar entornos: `conda env list`

:::

## Gesti√≥n de paquetes con `conda`

::: {.incremental}

* Instalar un paquete: `conda install <paquete>`
* Eliminar un paquete: `conda remove <paquete>`
* Listar paquetes: `conda list`

:::

## `pip` vs `conda`

::: {.incremental}

* `pip` es el gestor de paquetes oficial de Python
* `conda` es el gestor de paquetes de Anaconda
* `conda` es m√°s completo (y lento) que `pip` (e.g., gesti√≥n de entornos)
* `conda` se basa en binarios, mientras que `pip` en c√≥digo fuente (portabilidad, velocidad)
* `conda` comprueba potenciales conflictos entre dependencias, con resoluci√≥n autom√°tica de conflictos
* `pip` usa PyPI (Python Package Index), mientras que `conda` usa Anaconda Cloud (pese a que tambi√©n puede usar PyPI y otros repositorios)

:::

# Sintaxis

## Comentarios

```python
# Esto es un comentario de una l√≠nea

"""
Esto es un comentario
de varias l√≠neas
"""
```

## Variables

```python
# Asignaci√≥n
a = 1
b = 2
c = a + b

# Tipado din√°mico
a = 1
a = "hola"
```

## Operadores

| Operador | Descripci√≥n |
| --- | --- |
| `+` | Suma |
| `-` | Resta |
| `*` | Multiplicaci√≥n |
| `**` | Potencia |
| `/` | Divisi√≥n |
| `//` | Divisi√≥n entera |
| `%` | M√≥dulo |
| `==` | Igualdad (valor) |
| `is` | Identidad (referencia) |
| `!=` | Desigualdad (valor) |
| `is not` | No identidad (referencia) |
| `> / >= / < / <=` | Mayor / Mayor o igual / Menor / Menor o igual |
| `and` | Logical AND |
| `or` | Logical OR |
| `not` | Logical NOT |
| `in` | Contenido |
| `not in` | No contenido |

## Condicionales

```python
if a > b:
    print("a es mayor que b")
elif a < b:
    print("a es menor que b")
else:
    print("a es igual que b")
```

## Bucles

```{python}
# Bucle while
i = 0
while i < 10:
    print(i)
    i += 1

# Bucle for
for i in range(10):
    print(i)
```

## Funciones

```{python}
def funcion(a, b):
    return a + b


print(funcion(1, 2))
```

## Clases

::: {.incremental}

* Las clases son plantillas para crear objetos
* Los objetos son instancias de una clase
* Las clases pueden tener atributos y m√©todos
* Los atributos son variables de la clase
* Los m√©todos son funciones de la clase

:::

## Clases ‚Äì m√©todos

::: {.incremental}

* Los m√©todos pueden ser de instancia, de clase o est√°ticos
* Cu√°ndo utilizar cada tipo de m√©todo:
    * De instancia: acciones pertinenentes a una instancia (self)
    * De clase: crear constructores alternativos (factory), acceder a los atributos de la clase (cls) (e.g., tipo de figura geom√©trica)
    * Est√°tico: utilidades de la clase (e.g., conversi√≥n de unidades)

:::

## Clases ‚Äì Ejemplo

* `__init__`: constructor
* `self`: referencia a la instancia de la clase
* `@classmethod`: decorador para m√©todos de clase
* `@staticmethod`: decorador para m√©todos est√°ticos

```{python}
class Clase:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def metodo(self):
        print(self.a + self.b)

    @classmethod
    def metodo_clase(cls):
        print("M√©todo de clase")

    @staticmethod
    def metodo_estatico():
        print("M√©todo est√°tico")


objeto = Clase(1, 2)
objeto.metodo()
Clase.metodo_clase()
Clase.metodo_estatico()
```

## Clases ‚Äì Constructores alternativos

```{python}
class Clase:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    @classmethod
    def from_string(cls, string):
        a, b = string.split(",")
        return cls(a, b)


objeto = Clase.from_string("1,2")
print(objeto.a)
```

## Clases ‚Äì Herencia

* La herencia permite crear clases que heredan los atributos y m√©todos de otra clase
* La clase padre se conoce como *superclase* y la clase hija como *subclase*
* La subclase puede sobreescribir los m√©todos de la superclase, pero no existe el concepto de sobrecarga de m√©todos

```python
class ClaseHija(Clase):
    def __init__(self, a, b, c):
        super().__init__(a, b)
        self.c = c

    def metodo(self):
        super().metodo()
        print(self.c)
        
objeto = ClaseHija(1, 2, 3)
objeto.metodo()
```

# Tipos de datos

## N√∫meros

```python
# N√∫meros
a = 1 # Entero
b = 1.0 # Float
c = 1 + 1j # Complejo
```

## Cadenas de texto

```python
# Cadenas de texto
a = "Hola"
b = 'Hola'
c = """Hola
Mundo"""
```

## Cadenas de texto ‚Äì F-strings

```{python}
# F-strings
a = "mundo"
b = f"Hola {a}"
print(b)
```

## Booleanos

```python
# Booleanos
a = True
b = False
```

## None

* Valor especial que representa la ausencia de valor
* Equivalente a `null` en otros lenguajes

```python
# None
a = None
```

## Tipos de Secuencias

::: {.incremental}

* Tuplas
* Listas
* Secuencias (`range`, `enumerate`, `zip`)

:::

## Tuplas

::: {.incremental}

* Colecciones ordenadas de elementos
* No se pueden modificar
* Se pueden iterar (m√∫ltiples veces)

:::

```python
# Tuplas
tupla = (1, 2, 3, 4, 5)
tupla[0]
tupla[0:2]
tupla[0] = 0 # Error
```

## Listas

::: {.incremental}

* Colecciones ordenadas de elementos
* Se pueden modificar
* Se pueden iterar (m√∫ltiples veces)
* Se pueden rebanar (slicing), concatenar, ordenar y filtrar

:::

```python
# Listas
lista = [1, 2, 3, 4, 5]
lista[0]
lista[0:2]
lista[0] = 0
```

## Secuencias

* Objetos iterables immutables (no se pueden modificar)

```python
# Secuencias (range)
secuencia = range(10)
secuencia[0]
secuencia[0:2]
```

```{python}
# Secuencias (enumerate)
secuencia = enumerate(["a", "b", "c"])
for i, v in secuencia:
    print(i, v)
```

```{python}
# Secuencias (zip)
secuencia = zip(["a", "b", "c"], [1, 2, 3])
for i, v in secuencia:
    print(i, v)
```

## Tipos de Mappings

::: {.incremental}

* Diccionarios
* Conjuntos

:::

## Diccionarios

* Colecciones de pares clave-valor

```python
# Diccionarios
diccionario = {"a": 1, "b": 2, "c": 3}
diccionario["a"]
diccionario["a"] = 0
```

## Conjuntos (sets)

* Colecciones no ordenadas de elementos √∫nicos

```python
# Conjuntos
conjunto = {1, 2, 3, 4, 5}
conjunto.add(6)
conjunto.remove(6)
```

## Comprehensions

* Sintaxis para crear colecciones a partir de otras colecciones

```{python}
# Comprensi√≥n de listas
lista = [x + 1 for x in range(10)]
print(lista)
```

```{python}
# Comprensi√≥n de diccionarios
diccionario = {x: x + 1 for x in range(10)}
print(diccionario)
```

```{python}
# Comprensi√≥n de conjuntos
conjunto = {x + 1 for x in range(10)}
print(conjunto)
```

# Conceptos avanzados

## Decoradores

* Funciones que modifican el comportamiento de otras funciones
* Se utilizan para a√±adir funcionalidad a una funci√≥n sin modificarla

```{python}
def decorador(funcion):
    def wrapper(*args, **kwargs):
        print("Antes de la funci√≥n")
        funcion(*args, **kwargs)
        print("Despu√©s de la funci√≥n")

    return wrapper


@decorador
def funcion():
    print("Funci√≥n")


funcion()
```

## Expresiones lambda

::: {.incremental}

* Funciones an√≥nimas (sin nombre)
* Se utilizan para crear funciones sencillas que no se van a reutilizar
* Se pueden utilizar en cualquier lugar donde se necesite una funci√≥n
* Sintaxis: `lambda <argumentos>: <expresi√≥n>`
* Equivalente a `def funcion(<argumentos>): return <expresi√≥n>`

:::

```{python}
funcion = lambda x: x + 1
print(funcion(1))
```

## Generadores

::: {.incremental}

* Funciones que devuelven un iterador
* Se utilizan para crear secuencias de elementos
* Iterables una √∫nica vez, no se almacenan en memoria
* Sintaxis: `yield <elemento>`
* Equivalente a `return <elemento>` pero no finaliza la ejecuci√≥n de la funci√≥n

:::

```{python}
def generador():
    for i in range(10):
        yield i


for i in generador():
    print(i)
```

## Expresiones generadoras

* Sintaxis para crear generadores de forma m√°s sencilla
* Se utilizan para crear secuencias de elementos

```{python}
lista = [1, 2, 3, 4, 5]
generador = (x + 1 for x in lista)
for i in generador:
    print(i)
```

# Estructura de programas

## M√≥dulos

::: {.incremental}

* Un m√≥dulo es un fichero con extensi√≥n `.py`
* Un m√≥dulo puede contener funciones, clases, variables, etc.
* Un m√≥dulo puede importar otros m√≥dulos
* Un m√≥dulo puede ser ejecutado directamente o importado por otro m√≥dulo

:::

## M√≥dulos ‚Äì Ejemplo

* `__name__`: nombre del m√≥dulo
* `__main__`: nombre del m√≥dulo principal
* Por qu√© utilizar `if __name__ == "__main__"`
    * Organizaci√≥n del c√≥digo (separar c√≥digo de ejecuci√≥n directa del c√≥digo de importaci√≥n)
    * Evitar ejecuci√≥n de c√≥digo al importar un m√≥dulo
    * Encapsulaci√≥n de c√≥digo de ejecuci√≥n directa

```python
# modulo.py
def funcion():
    print("Hola mundo")

if __name__ == "__main__":
    funcion()
```

```bash
$ python modulo.py
Hola mundo
```

```python
# otro_modulo.py
import modulo

modulo.funcion()
```

```bash
$ python otro_modulo.py
Hola mundo
```

## Paquetes

::: {.incremental}

* Un paquete es un conjunto de m√≥dulos
* Un paquete es un directorio con un fichero `__init__.py`
* Un paquete puede contener otros paquetes (subpaquetes)
* Un paquete puede ser importado por otro paquete o m√≥dulo

:::

## `__init__.py`

::: {.incremental}

* Fichero vac√≠o que indica que un directorio es un paquete
* Se ejecuta al importar un paquete
* Se utiliza para inicializar el paquete (e.g., importar m√≥dulos)

:::

## Paquetes ‚Äì Ejemplo

```bash
$ tree
.
‚îú‚îÄ‚îÄ main.py
‚îî‚îÄ‚îÄ paquete
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ modulo.py
```

```python
# main.py
import paquete.modulo

paquete.modulo.funcion()
```

```bash
$ python main.py
Hola mundo
```

# Entornos virtuales

## Entornos virtuales

::: {.incremental}

* Un entorno virtual es un directorio que contiene una instalaci√≥n de Python
* Permite aislar las dependencias de un proyecto
* Permite tener m√∫ltiples versiones de Python instaladas en el sistema
* Permite tener m√∫ltiples versiones de las dependencias de un proyecto

:::

## Entornos virtuales ‚Äì Ejemplo

::: {.incremental}

* Crear un entorno virtual: `python -m venv venv`
* Activar un entorno virtual: `source venv/bin/activate` (Linux & Mac) o `venv\Scripts\activate.bat` (Windows)
* Desactivar un entorno virtual: `deactivate` (Linux & Mac) o `venv\Scripts\deactivate.bat` (Windows)
* Instalar dependencias: `pip install <paquete>`
* Exportar dependencias: `pip freeze > requirements.txt`

:::

```bash
$ python -m venv venv
$ source venv/bin/activate # o venv\Scripts\activate.bat
$ pip install numpy
$ pip freeze > requirements.txt
$ deactivate # o source venv/bin/deactivate, venv\Scripts\deactivate.bat
```
